---
title: "Homework 5"
author: "Yuhsiang Hong"
date: "2/27/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(gapminder)
library(broom)
library(rsample)
```

## Problem 1

In this exercise we will work with the total number of words spoken by characters of different races and genders in the Lord of the Rings movies.

1. Get the data in a single data frame. Create 3 data frames (or tibbles) from these files.

```{r}
movie1 <- read.csv("https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv", stringsAsFactors = FALSE)
movie2 <- read.csv("https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv", stringsAsFactors = FALSE)
movie3 <- read.csv("https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv", stringsAsFactors = FALSE)
# Combine the 3 data frames into one
movie <- bind_rows(movie1, movie2, movie3)
movie
```

2. Tidy the combined data frame by creating new variables “Gender” and “Words”.

```{r}
movie <- pivot_longer(movie, "Female":"Male", names_to = "Gender", values_to = "Words")
head(movie)
```

3. Use the combined data frame to answer the following questions

(a) How many words were spoken in each movie?

```{r}
aggregate(Words ~ Film, movie, sum)
```

(b) How many words were spoken by each gender in total?

```{r}
aggregate(Words ~ Gender, movie, sum)
```

(c) How many words were spoken by each race in total?

```{r}
aggregate(Words ~ Race, movie, sum)
```

4. Create a data frame with totals by race and movie, calling it by_race_film.

```{r}
by_race_film <- aggregate(Words ~ Film + Race, movie, sum)
by_race_film
```

## Problem 2

1. Split/group the gapminder data by country. For each country, fit an ARIMA(0,0,1) or MA(1) model to lifeExp, and produce a tibble that contains the country-wise values of AIC and BIC, two measures of goodness of model fit. Obtain a scatter plot of AIC versus BIC and comment.

```{r}
# Grouped by country
arima001 <- as_tibble(gapminder) %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(glance(arima(.$lifeExp, order = c(0,0,1))))
head(arima001)
```

```{r}
ggplot(arima001, aes(AIC, BIC)) + 
  geom_point() + 
  ggtitle("Scatter plot of AIC versus BIC from ARIMA(0,0,1)") + 
  theme(plot.title = element_text(size = 12)) + 
  theme(plot.title = element_text(hjust = 0.5))
```

From the above plot, AIC and BIC have a positive correlation. Moreover, their relationship is a straight line with positive slope. In other words, when AIC increases across different countries, BIC also increases.

2. Now repeat the previous step for four other models: ARIMA(0,0,1), ARIMA(0,0,2), ARIMA(0,0,3), ARIMA(0,1,0), ARIMA(0,1,1), and in a single plot, show boxplots of AIC values for the five models. Based on the boxplot, which of these five models do you think fits the data best for most countries?

```{r}
arima001 <- as_tibble(gapminder) %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(glance(arima(.$lifeExp, order = c(0,0,1)))) %>% mutate(model = "ARIMA(0,0,1)")

arima002 <- as_tibble(gapminder) %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(glance(arima(.$lifeExp, order = c(0,0,2)))) %>% mutate(model = "ARIMA(0,0,2)")

arima003 <- as_tibble(gapminder) %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(glance(arima(.$lifeExp, order = c(0,0,3)))) %>% mutate(model = "ARIMA(0,0,3)")

arima010 <- as_tibble(gapminder) %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(glance(arima(.$lifeExp, order = c(0,1,0)))) %>% mutate(model = "ARIMA(0,1,0)")

arima011 <- as_tibble(gapminder) %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(glance(arima(.$lifeExp, order = c(0,1,1)))) %>% mutate(model = "ARIMA(0,1,1)")
```

```{r}
plot_data = rbind(arima001, arima002, arima003, arima010, arima011)
ggplot(plot_data, aes(x=model, y=AIC, fill=model)) + geom_boxplot() + 
  ggtitle("AIC of Different ARIMA models") + 
  theme(plot.title = element_text(size = 12)) + 
  theme(plot.title = element_text(hjust = 0.5))
```

ARIMA(0,1,1) has the least AIC for most coutries compared to other models as we can see from the boxplots; therefore, I think ARIMA(0,1,1) fits the data the best.

3. Filter the data only for continent Europe. For the best model identified in step 2, create a tibble showing the country-wise model parameters (moving average coefficients) and their standard errors using the broom package.

Moving average coefficients are in the third column and standard errors are in the fourth column.

```{r}
result <- as_tibble(gapminder) %>% filter(continent == "Europe") %>% group_by(country) %>% select(country, lifeExp) %>% 
  do(tidy(arima(.$lifeExp, order = c(0,1,1))))
head(result)
```

4. Now filter the data only for year 1992. Plot lifeExp against log10(gdpPercapita). Fit a linear model of lifeExp on log10(gdpPercapita) using population as weights and obtain (i) bootstrapped 95% confidence intervals for the slope coefficient and (ii) bootstrapped 90% prediction intervals for each data point using 500 bootstrapped samples (show a plot of the prediction intervals). Compare the bootstrapped 95% confidence intervals for the estimated cofficient with those generated automatically by the lm() function. Which one is wider?

Fit linear regression to the dataset and obtain the 95% confidence intervals of slope coefficient from lm() function.

```{r}
lr <- as_tibble(gapminder) %>% filter(year == 1992) %>% 
  lm(lifeExp ~ log10(gdpPercap), data = ., weights = pop)
confint(lr, 'log10(gdpPercap)', level=0.95)
```

Bootstraps 500 times and compute 95% confidence intervals for slope coefficient.

```{r}
set.seed(2021)
boot_gmd <- as_tibble(gapminder) %>% filter(year == 1992) %>% bootstraps(500)

boot_lm1 <- map(boot_gmd$splits, ~as.data.frame(.)) %>% 
  map(~tidy(lm(lifeExp ~ log10(gdpPercap), data = ., weights = pop))) %>% bind_rows(.)

alpha <- 0.05
ci_boot <- boot_lm1 %>% group_by(term) %>% 
  summarize(conf.low = quantile(estimate, alpha / 2),
            conf.high = quantile(estimate, 1 - alpha / 2))
ci_boot[2,]
```

The 95% bootstrapped confidence interval is wider than the one that automatically generated by lm() function.

Compute 90% prediction intervals for each data point using 500 bootstrapped samples and show a plot of the prediction intervals. (The shaded part is the prediction interval.)

```{r}
boot_lm2 <- map(boot_gmd$splits, ~as.data.frame(.)) %>%
  map(~augment(lm(lifeExp ~ log10(gdpPercap), data = ., weights = pop))) %>% bind_rows(.)

alpha <- 0.1
bootlm_pred <- boot_lm2 %>% group_by(log10.gdpPercap.) %>%
  summarize(conf.low = quantile(.fitted, alpha / 2), 
            conf.high = quantile(.fitted, 1 - alpha / 2), 
            median = median(.fitted))

ggplot(data = augment(lr), aes(log10.gdpPercap.)) + geom_point(aes(y = lifeExp)) + 
  geom_line(aes(y = .fitted)) + 
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), data = bootlm_pred, alpha = 0.1) +
  ggtitle("Bootstrapped 90% Prediction Intervals") + 
  theme(plot.title = element_text(size = 12)) + 
  theme(plot.title = element_text(hjust = 0.5))
```
